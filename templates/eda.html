<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Interactive EDA — Full</title>

  <!-- Fonts & Bootstrap -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Poppins:wght@300;400;600&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <meta name="viewport" content="width=device-width,initial-scale=1">
</head>

<body class="dark-mode">
  <button id="sidebarToggle" class="sidebar-toggle-btn">☰</button>


  <canvas id="particle-canvas" aria-hidden="true"></canvas>

  <aside class="sidebar">

    <div class="logo glass-logo">
      <h2 class="logo-text">Insight</h2>
    </div>

    <nav>
      <ul class="menu">
        <li class="active"><a href="/">Prediction Form</a></li>
        <li><a href="/analytics">Analytics</a></li>
        <li><a href="/eda">Charts</a></li>
      </ul>
    </nav>
    <div class="toggle-theme">
      <label class="switch">
        <input id="themeToggle" type="checkbox" />
        <span class="slider"></span>
      </label>
      <span class="toggle-label">Dark Mode</span>
    </div>
  </aside>



  <div class="main wrapper">
    <div class="particles"></div>
    <div class="ai-waves"></div>

    <h1 class="neon-heading">Interactive EDA </h1>
    <p class="small-muted">Pick a chart type and then pick features. Context controls will appear automatically.</p>

    <!-- Controls -->
    <div class="controls mt-3">

      <div class="form-group">
        <label>Chart Type</label>
        <select id="chartType" class="form-control glass-input">
          <option value="">-- Select Chart --</option>
          <option value="hist">Histogram</option>
          <option value="box">Boxplot</option>
          <option value="scatter2d">Scatter 2D</option>
          <option value="scatter3d">Scatter 3D</option>
          <option value="pie">Pie / Donut</option>
          <option value="bar">Bar</option>
          <option value="heatmap">Correlation Heatmap</option>
        </select>
      </div>

      <div class="form-group hidden" id="xDiv">
        <label>X (numeric / category)</label>
        <select id="xSelect" class="form-control glass-input"></select>
      </div>

      <div class="form-group hidden" id="yDiv">
        <label>Y (numeric)</label>
        <select id="ySelect" class="form-control glass-input"></select>
      </div>

      <div class="form-group hidden" id="zDiv">
        <label>Z (numeric - 3D)</label>
        <select id="zSelect" class="form-control glass-input"></select>
      </div>

      <div class="form-group hidden" id="colorDiv">
        <label>Color (optional)</label>
        <select id="colorSelect" class="form-control glass-input"></select>
      </div>

      <div class="form-group hidden" id="sizeDiv">
        <label>Size (optional)</label>
        <select id="sizeSelect" class="form-control glass-input"></select>
      </div>

      <div class="form-group hidden" id="aggDiv">
        <label>Aggregation</label>
        <select id="aggSelect" class="form-control glass-input">
          <option value="count">Count</option>
          <option value="mean">Mean (target)</option>
          <option value="sum">Sum (target)</option>
        </select>
      </div>

      <div class="form-group hidden" id="groupDiv">
        <label>Group by (categorical)</label>
        <select id="groupSelect" class="form-control glass-input"></select>
      </div>

      <div class="form-group hidden" id="trendDiv">
        <label class="d-block">Trendline</label>
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="trendlineToggle">
          <label class="form-check-label small-muted" for="trendlineToggle">Show linear regression</label>
        </div>
      </div>

      <div class="form-group">
        <button id="drawBtn" class="glass-btn primary">Draw Chart</button>
      </div>
    </div>

    <!-- Chart card -->
    <div class="chart-card mt-3">
      <div id="chartStatus" class="small-muted">No chart drawn yet.</div>
      <div class="heatmap-container">
        <div id="chartArea"></div>
      </div>

    </div>

  </div>






  <script>
/* ================== Data from Flask ================== */
const df = {{ df_json | tojson | safe }};
const numericCols = {{ numeric_cols | tojson | safe }};
const categoricalCols = {{ categorical_cols | tojson | safe }};
const target = "{{ target if target is defined else 'Correct_Revenue' }}";

/* Small helpers */
const $ = id => document.getElementById(id);
function avg(arr) { return arr.reduce((a, b) => a + b, 0) / arr.length; }
function toNum(v) { return (v === null || v === undefined || v === "" || isNaN(Number(v))) ? NaN : Number(v); }

/* ---------- Fill selects ---------- */
function fillSelect(sel, arr, includeEmpty = true) {
  let html = includeEmpty ? '<option value="">--Select--</option>' : '';
  arr.forEach(x => html += `<option value="${x}">${x}</option>`);
  sel.innerHTML = html;
}

fillSelect($('xSelect'), numericCols.concat(categoricalCols));
fillSelect($('ySelect'), numericCols, false);
fillSelect($('zSelect'), numericCols, false);
fillSelect($('colorSelect'), numericCols.concat(categoricalCols));
fillSelect($('sizeSelect'), numericCols);
fillSelect($('groupSelect'), categoricalCols);

/* ---------- Layout ---------- */
function defaultLayout(title) {
  return {
    title: { text: title, font: { size: 20, color: '#9b5cff' }, x: 0.5 },
    margin: { l: 60, r: 40, t: 70, b: 60 },
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    font: { color: '#9b5cff' },
    legend: { orientation: 'h', x: 0.5, xanchor: 'center' }
  };
}

/* ---------- Aggregation ---------- */
function groupAggregate(rows, by, agg, valueCol) {
  const map = {};
  rows.forEach(r => {
    const key = r[by] == null ? 'Missing' : String(r[by]);
    const val = toNum(r[valueCol]);
    if (!map[key]) map[key] = { sum: 0, cnt: 0 };
    map[key].sum += isNaN(val) ? 0 : val;
    map[key].cnt += 1;
  });
  const labels = Object.keys(map);
  if (agg === 'count') return { x: labels, y: labels.map(l => map[l].cnt) };
  if (agg === 'mean') return { x: labels, y: labels.map(l => map[l].sum / map[l].cnt) };
  if (agg === 'sum') return { x: labels, y: labels.map(l => map[l].sum) };
  return { x: labels, y: labels.map(l => map[l].cnt) };
}

/* ---------- Regression ---------- */
function corr(x, y) {
  const xm = avg(x), ym = avg(y);
  let num = 0, dx = 0, dy = 0;
  for (let i = 0; i < x.length; i++) {
    const a = x[i] - xm, b = y[i] - ym;
    num += a * b; dx += a * a; dy += b * b;
  }
  return num / Math.sqrt(dx * dy || 1);
}

function linreg(x, y) {
  const xm = avg(x), ym = avg(y);
  let num = 0, den = 0;
  for (let i = 0; i < x.length; i++) {
    num += (x[i] - xm) * (y[i] - ym);
    den += (x[i] - xm) ** 2;
  }
  const m = den === 0 ? 0 : num / den;
  const b = ym - m * xm;
  const rss = x.map((xi, i) => (y[i] - (m * xi + b)) ** 2).reduce((a, b) => a + b, 0);
  const tss = y.map(yi => (yi - ym) ** 2).reduce((a, b) => a + b, 0);
  return { m, b, r2: 1 - (rss / (tss || 1)) };
}

/* ---------- Chart functions ---------- */
function drawHistogram(xCol) {
  const vals = df.map(r => toNum(r[xCol])).filter(v => !isNaN(v));
  Plotly.newPlot('chartArea', [{
    x: vals,
    type: 'histogram',
    marker: { color: '#1BC7D8' }
  }], defaultLayout(`Histogram — ${xCol}`));
}

function drawBoxplot(xCol, groupBy) {
  if (groupBy) {
    const groups = {};
    df.forEach(r => {
      const g = r[groupBy] == null ? 'Missing' : String(r[groupBy]);
      groups[g] = groups[g] || [];
      const v = toNum(r[xCol]); if (!isNaN(v)) groups[g].push(v);
    });
    const traces = Object.keys(groups).map(k => ({ y: groups[k], name: k, type: 'box' }));
    Plotly.newPlot('chartArea', traces, defaultLayout(`Boxplot — ${xCol} by ${groupBy}`));
  } else {
    const vals = df.map(r => toNum(r[xCol])).filter(v => !isNaN(v));
    Plotly.newPlot('chartArea', [{ y: vals, type: 'box' }], defaultLayout(`Boxplot — ${xCol}`));
  }
}

function drawPie(catCol) {
  const counts = {};
  df.forEach(r => {
    const k = r[catCol] == null ? 'Missing' : String(r[catCol]);
    counts[k] = (counts[k] || 0) + 1;
  });
  Plotly.newPlot('chartArea', [{
    labels: Object.keys(counts),
    values: Object.values(counts),
    type: 'pie',
    hole: 0.4
  }], defaultLayout(`Pie — ${catCol}`));
}

function drawBar(catCol, agg, valueCol) {
  const out = groupAggregate(df, catCol, agg, valueCol);

  // generate different colors for each bar
  const colors = out.x.map((_, i) =>
    `hsl(${(i * 40) % 360}, 80%, 60%)`
  );

  Plotly.newPlot('chartArea', [{
    x: out.x,
    y: out.y,
    type: 'bar',
    marker: {
      color: colors
    }
  }], defaultLayout(`${agg} of ${valueCol} by ${catCol}`));
}

function drawScatter2D(xCol, yCol, colorCol, sizeCol, trend) {
  const x = df.map(r => toNum(r[xCol]));
  const y = df.map(r => toNum(r[yCol]));

  let marker = { color: '#FF66CC', size: 7, opacity: 0.8 };

  if (colorCol) marker.color = df.map(r => r[colorCol] ?? 'Missing');
  if (sizeCol) marker.size = df.map(r => Math.max(5, toNum(r[sizeCol]) || 5));

  const data = [{ x, y, mode: 'markers', type: 'scatter', marker }];

  if (trend) {
    const valid = df.map(r => ({ x: toNum(r[xCol]), y: toNum(r[yCol]) }))
      .filter(p => !isNaN(p.x) && !isNaN(p.y));

    if (valid.length >= 2) {
      const xs = valid.map(p => p.x);
      const ys = valid.map(p => p.y);
      const fit = linreg(xs, ys);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      data.push({
        x: [minX, maxX],
        y: [fit.m * minX + fit.b, fit.m * maxX + fit.b],
        mode: 'lines',
        name: `Trendline (R²=${fit.r2.toFixed(3)})`
      });
    }
  }

  Plotly.newPlot('chartArea', data, defaultLayout(`${yCol} vs ${xCol}`));
}

function drawScatter3D(xCol, yCol, zCol, colorCol) {
  Plotly.newPlot('chartArea', [{
    x: df.map(r => toNum(r[xCol])),
    y: df.map(r => toNum(r[yCol])),
    z: df.map(r => toNum(r[zCol])),
    mode: 'markers',
    type: 'scatter3d',
    marker: { color: colorCol ? df.map(r => r[colorCol]) : '#FF66CC' }
  }], defaultLayout(`3D: ${xCol} / ${yCol} / ${zCol}`));
}

function drawHeatmap() {
  const cols = numericCols;

  const matrix = cols.map(c1 =>
    cols.map(c2 => {
      const pts = df.map(r => ({
        x: toNum(r[c1]),
        y: toNum(r[c2])
      })).filter(p => !isNaN(p.x) && !isNaN(p.y));

      if (pts.length < 2) return 0;
      return corr(pts.map(p => p.x), pts.map(p => p.y));
    })
  );

  Plotly.newPlot("chartArea", [{
    z: matrix,
    x: cols,
    y: cols,
    type: "heatmap",

    // ⭐ Custom neon colorscale
    colorscale: [
      [0, "#00FFD1"],     // aqua
      [0.25, "#7A3CF3"],  // neon purple
      [0.5, "#1BC7D8"],   // cyan
      [0.75, "#FF66CC"],  // hot pink
      [1, "#00FFA2"]      // neon green
    ],

    zmin: -1,
    zmax: 1,
    showscale: true
  }], defaultLayout("Correlation Heatmap"));
}

/* ---------- Controls ---------- */
function resetControls() {
  ['xDiv', 'yDiv', 'zDiv', 'colorDiv', 'sizeDiv', 'aggDiv', 'groupDiv', 'trendDiv']
    .forEach(id => $(id).classList.add('hidden'));
}

function showControlsFor(chart) {
  resetControls();
  if (chart === 'hist') { $('xDiv').classList.remove('hidden'); }
  if (chart === 'box') { $('xDiv').classList.remove('hidden'); $('groupDiv').classList.remove('hidden'); }
  if (chart === 'pie') { $('xDiv').classList.remove('hidden'); }
  if (chart === 'bar') { $('xDiv').classList.remove('hidden'); $('aggDiv').classList.remove('hidden'); }
  if (chart === 'scatter2d') { ['xDiv', 'yDiv', 'colorDiv', 'sizeDiv', 'trendDiv'].forEach(id => $(id).classList.remove('hidden')); }
  if (chart === 'scatter3d') { ['xDiv', 'yDiv', 'zDiv', 'colorDiv'].forEach(id => $(id).classList.remove('hidden')); }
}

$('chartType').addEventListener('change', e => {
  showControlsFor(e.target.value);
  $('chartStatus').innerText = 'Controls updated.';
});

$('drawBtn').addEventListener('click', () => {
  const chart = $('chartType').value;
  if (!chart) return alert('Select chart type');

  const x = $('xSelect').value;
  const y = $('ySelect').value;
  const z = $('zSelect').value;
  const color = $('colorSelect').value;
  const size = $('sizeSelect').value;
  const agg = $('aggSelect').value;
  const group = $('groupSelect').value;
  const trend = $('trendlineToggle').checked;

  try {
    if (chart === 'hist') drawHistogram(x);
    else if (chart === 'box') drawBoxplot(x, group);
    else if (chart === 'pie') drawPie(x);
    else if (chart === 'bar') drawBar(x, agg, target);
    else if (chart === 'scatter2d') drawScatter2D(x, y, color || null, size || null, trend);
    else if (chart === 'scatter3d') drawScatter3D(x, y, z, color || null);
    else if (chart === 'heatmap') drawHeatmap();

    $('chartStatus').innerText = `${chart} rendered`;
  } catch (err) {
    console.error(err);
    alert('Rendering error: ' + err.message);
  }
});

resetControls();
</script>




  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const sidebar = document.querySelector(".sidebar");
      const toggle = document.getElementById("sidebarToggle");
      const closeBtn = document.getElementById("closeSidebar");

      toggle?.addEventListener("click", () => {
        sidebar.classList.toggle("open");
        toggle.textContent = sidebar.classList.contains("open") ? "✕" : "☰";
      });

      closeBtn?.addEventListener("click", () => {
        sidebar.classList.remove("open");
        toggle.textContent = "☰";
      });
    });
  </script>


</body>

</html>


<script src="{{ url_for('static', filename='script.js') }}"></script>
</body>

</html>